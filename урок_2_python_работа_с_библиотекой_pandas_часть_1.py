# -*- coding: utf-8 -*-
"""Урок 2. Python. Работа с библиотекой Pandas. Часть 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/kornilovaap/42334595cac6785f5079dddad8821b4f/-2-python-pandas-1.ipynb

# Загрузка данных
"""

# Импортируем в свой скрипт библиотеку Pandas
import pandas as pd

# Загружаем данные в Python c помощью бибилиотеки Pandas
df = pd.read_csv('advertising.csv')

# У метода read есть доп. параметры, которые можно указывать в скобках: 
df = pd.read_csv('advertising.csv', header = 0, sep = ',')

# Возвратим первые 5 строк загруженного датафрейма
df.head()

# Возвратим последние 5 строк загруженного датафрейма
df.tail()

"""# Статистика датасета"""

# Посмотрим количество строк в датафрейме
len(df)

# Посмотрим количество строк и столбцов в датафрейме
df.shape

# Общая статистика датасета
df.info()

# Описательная статистика для числовых столбцов датасета
df.describe()

# Описательная статистика для нечисловых столбцов датасета
df.describe(include=['object', 'bool'])

# Подсчет встречаемости категорий в частотах
df['Clicked on Ad'].value_counts()

# Подсчет встречаемости категорий в долях
df['Country'].value_counts(normalize = True).head()

# Подсчет числа уникальных значений столбца
df['City'].nunique()

# Вывод на экран всех уникальных значений столбца
df['City'].unique()[:10]

"""# Извлечение данных"""

# Извлечение отдельного столбца
df['Daily Time Spent on Site']

# Другой способ (но лучше не прибегать к нему)
df.Age

# Извлечение нескольких столбцов
df[['Country', 'City', 'Area Income']]

# Добавление новых столбцов
df['Site time share'] = df['Daily Time Spent on Site'] / df['Daily Internet Usage']
df['Site time share'].head()

# Применение статистических методов к столбцам (группам столбцов), например, вычисление среднего:
df[['Daily Time Spent on Site', 'Daily Internet Usage', 'Age']].mean()

"""# Фильтрация данных"""

# Фильтрация данных встроенными способами
filtered_age = df[df['Age'] > 35]
filtered_age.head()

# Фильтрация данных с использованием нескольких условий
filtered_age_country = df[(df['Age'] > 35) & (df['Country'] == 'Australia')]
filtered_age_country.head()

# Фильтрация данных с помощью метода .loc
df.loc[100:105,['Country', 'Area Income']]

# Фильтрация датасета по значению столбца с помощью метода .loc
df.loc[df['Clicked on Ad'] == 1]

# Получение значений столбца для определенного фильтра
df.loc[df['Clicked on Ad'] == 1, 'Age']

# Фильтрация данных с помощью метода .iloc
df.iloc[:,[1, 6]]

# Фильтрация данных с помощью метода .filter
country_stats = df.filter(items = ['Country', 'Area Income'])
country_stats.head()

# Фильтрация строк с помощью метода .query
country_stats.query('`Area Income` > 50000').head()

# Фильтрация текстовых стобцов с помощью метода .contains
df[df['Country'].str.contains('ru', case = False)].head()

df[df['Country'].str.contains('ru|bo|ja', case = False)].tail()

"""# Сортировка данных"""

# Применим сортировку данных для составления рейтинга ТОП-5 пользователей по ср. тратам времени на Интернет
df.sort_values(by = 'Daily Internet Usage', ascending = False).head()

"""# Небольшой челлендж"""

# Задание 1: выясните, в какой группе пользователей среди "молодежи" (до 30 лет) или "пенсионеров" (больше 60 лет) больше доля кликов на рекламу сайта?

# Решение:

print('В группе молодежи доля кликнувших на рекламу:', df['Clicked on Ad'].loc[df['Age'] > 60].mean() * 100, '%')
print('В группе пенсионеров доля кликнувших на рекламу:', df['Clicked on Ad'].loc[df['Age'] < 30].mean() * 100, '%')

# Задание 2: определите, мужчины или женщины больше времени сидят в интернете?

# Решение:

print('Мужчины проводят в интернете в среднем', round(df.query('Male == 1')['Daily Internet Usage'].mean(),1), 'минут в день')
print('Женщины проводят в интернете в среднем', round(df.query('Male == 0')['Daily Internet Usage'].mean(),1), 'минут в день')

# Задание №3: Определеите ТОП-15 стран по количеству пользоваталей на сайте.

df['Country'].value_counts().head(15)

"""# Объединение датафреймов"""

# Предположим, что у нас в датасете есть еще один столбец user_id:
import numpy as np

df = pd.read_csv('advertising.csv')

df['User_id'] = pd.Series(range(1000,2000))

new_order = [10,0,1,2,3,4,5,6,7,8,9]
df = df[df.columns[new_order]]

df.head()

# Разделим наш датасет на три разных датасета: сведения о действиях пользователя на сайте, личнные данные и макроэкономические данные
cols_1 = ['User_id', 'Daily Time Spent on Site', 'Ad Topic Line', 'Timestamp', 'Clicked on Ad']
df_site = df[cols_1]

print('Размер датасета df_site:', df_site.shape)
df_site.head()

cols_2 = ['User_id', 'Male', 'Age', 'Country', 'City', 'Daily Internet Usage']
df_personal = df[cols_2]

print('Размер датасета df_personal:', df_personal.shape)
df_personal.head()

cols_3 = ['Country', 'City','Area Income']

df_macro = df[cols_3][:-50]

print('Размер датасета df_macro:', df_macro.shape)
df_macro.head()

# Предположим, что мы получили эти три датасета из разных источников и теперь нам нужно их объединить

df_2 = pd.merge(df_site, df_personal, on = 'User_id', how = 'left')

print('Размер датасета df_2:', df_2.shape)
df_2.head()

# Задание: объедините датасет df_2 с датасетом df_macro

# Решение:

df_3 = df_2.merge(df_macro, left_on = ['Country', 'City'], right_on = ['Country', 'City'], how = 'left')

print('Размер датасета df_3:', df_3.shape)
df_3.head()

# Т.к. в датасете macro было меньше данных (n = 950), то часть строк в новом датасете будут пустыми или NaN
df_3[df_3.isna() == True]
print('Частично пустых строк:', df_3.isna().sum())

# Посмотрим сколько бы строк было в объединенном датасете, если бы метод объединения был 'inner':

df_4 = df_2.merge(df_macro, on = ['Country', 'City'], how = 'inner')

print('Размер датасета df_4:', df_4.shape)
df_4.head()

# Посмотрим сколько бы строк было в объединенном датасете, если бы метод объединения был 'right':

df_5 = df_2.merge(df_macro, on = ['Country', 'City'], how = 'right')

print('Размер датасета df_5:', df_5.shape)
df_5.head()

# Объдинение датасетов методом join

df_6 = df_site.set_index('User_id')
df_7 = df_personal.set_index('User_id')

df_8 = df_6.join(df_7, how = 'inner')

print('Размер датасета df_8:', df_8.shape)
df_8.head()